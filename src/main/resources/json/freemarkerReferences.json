[
  {
    "name": "Product",
    "type": "Variable",
    "documentation": "",
    "insertRule": "append",
    "parameters": "name, productId, price",
    "example": "${product.name}",
    "output": "Table",
    "template": "product"
  },
  {
    "name": "Customer",
    "type": "Variable",
    "documentation": "",
    "insertRule": "append",
    "parameters": "name, address, phoneNumber, hobbies",
    "example": "${customer.phoneNumber}",
    "output": "+1 302-246-1037",
    "template": "customer"
  },
  {
    "name": "Assign",
    "type": "Control and Loops",
    "documentation": "With this you can create a new Variable, or replace an existing Variable. Note that only top-level Variables can be created/replaced (i.e. you can't create/replace <span>some_hash.subvar</span>, but <span>some_hash</span>).",
    "insertRule": "insert",
    "parameters": [
      "Name",
      "Assignment operator",
      "Value"
    ],
    "example": "<#assign name1 = value1>\n<#assign seq = [\"foo\", \"bar\", \"baz\"]>",
    "template": "<#assign name1 = value1>\n"
  },
  {
    "name": "Attempt, recover",
    "type": "Control and Loops",
    "documentation": "These directives are used if you want the page successfully outputted even if the outputting of a certain part of the page fails. If an error occurs during the execution of the <span><em>attempt block</em></span>, then the output of the <span><em>attempt block</em></span> is rolled back (and the error is logged, with the default configuration at least), and the <span><em>recover block</em></span> is executed instead, then template execution continues normally after the <span><em>recover block</em></span>. If no error occurs during the execution of the <span><em>attempt block</em></span>, then the <span><em>recover block</em></span> is ignored.",
    "insertRule": "insert",
    "parameters": [
      "attempt block",
      "recover block"
    ],
    "example": "<#attempt>\n  Optional content.\n<#recover>\n  Ops! The optional content is not available.\n</#attempt>",
    "template": "<#attempt>\n  attempt block\n<#recover>\n  recover block\n</#attempt>\n"
  },
  {
    "name": "Function, return",
    "type": "Control and Loops",
    "documentation": "Creates a method Variable (in the current namespace, if you know namespace feature). <span>Return</span> directive must have a parameter that specifies the return value of the method, and that attempts to write to the output will be ignored. If the <span><em></#function></span><em> is reached (i.e. there was no <span>return <em>returnValue</em></span>), then the return value of the method is an undefined Variable.",
    "insertRule": "insert",
    "parameters": "<ul><li><span>name</span>: name of method Variable (not expression).</li><li><span>param1, param2, ...etc.</span>: the name of the local Variables store the parameter values (not expression);</li><li><span>returnValue</span>: the expression that calculates the value of the method call.</li></ul>",
    "example": "<#function avg x y>\n  <#return (x + y) / 2>\n</#function>\n${avg(10, 20)}",
    "template": "<#function name param1 param2 ... paramN>\n  ...\n  <#return returnValue>\n  ...\n</#function>\n"
  },
  {
    "name": "If, else, elseif",
    "type": "Control and Loops",
    "documentation": "You can use <span>if, elseif</span> and <span>else</span> directives to conditionally skip a section of the template. The <span><em>condition</em></span>-s must evaluate to a boolean value, or else an error will abort template processing. The <span>elseif</span>-s and <span>else</span>-s must occur inside <span>if</span>(that is, between the <span>if</span> start-tag and end-tag). The <span>if</span> can contain any number of <span>elseif</span>-s (including 0) and at the end optionally one <span>else</span>.",
    "insertRule": "insert",
    "parameters": "<ul><li><span>condition, condition2, ...etc.</span>:Expression evaluates to a boolean value.</li></ul>",
    "example": "<#if x == 1>\n  x is 1\n<#else>\n  x is not 1\n</#if>",
    "template": "<#if condition>\n  ...\n<#elseif condition2>\n  ...\n...\n<#else>\n  ...\n</#if>\n"
  },
  {
    "name": "Boolean",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String converted to boolean value. The String must be true or false (case sensitive!), or must be in the format specified by the boolean_format setting.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"true\"?boolean}",
    "output": "true",
    "template": "?boolean"
  },
  {
    "name": "Capitalize first",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String with the very first word of the String capitalized.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"green mouse\"?cap_first}",
    "output": "Green mouse",
    "template": "?cap_first"
  },
  {
    "name": "Capitalize",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String with all words capitalized.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"GreEN mouse\"?capitalize}",
    "output": "Green Mouse",
    "template": "?capitalize"
  },
  {
    "name": "Contains",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Returns if the subString specified as the parameter to this built-in occurrs in the String.",
    "insertRule": "append",
    "parameters": "String",
    "example": "<#if \"piceous\"?contains(\"ice\")>It contains \"ice\"</#if>",
    "output": "It contains \"ice\"",
    "template": "?contains(String)"
  },
  {
    "name": "Date to string",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String value converted to a date, time, or date-time value. It will expect the format specified by the date_format, time_format and datetime_format settings. If the String is not in the appropriate format, an error will abort template processing when you try to access this built-in. You can also specify the format explicitly like ?datetime.format (and hence also as ?datetime[\"format\"]) or ?datetime(\"format\"); these three forms do the same. The format can be specified similarly with ?date and ?time too. ",
    "insertRule": "append",
    "parameters": "String",
    "example": "<#assign someDate = \"12/25/1995\"?date(\"MM/dd/yyyy\")>",
    "output": "25 DEC 1995",
    "template": "?date"
  },
  {
    "name": "Ends with",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Returns whether this String ends with the subString specified in the parameter. For example \"ahead\"?ends_with(\"head\") returns boolean true. Also, \"head\"?ends_with(\"head\") will return true.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"ahead\"?ends_with(\"head\")}",
    "output": "true",
    "template": "?ends_with(p1)"
  },
  {
    "name": "Index of",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Returns the index within this String of the first occurrence of the specified subString. For example, \"abcabc\"?index_of(\"bc\") will return 1 (don't forget that the index of the first character is 0). Also, you can specify the index to start the search from: \"abcabc\"?index_of(\"bc\", 2) will return 4. There is no restriction on the numerical value of the second parameter: if it is negative, it has the same effect as if it were zero, and if it is greater than the length of this String, it has the same effect as if it were equal to the length of this String. Decimal values will be truncated to integers.",
    "insertRule": "append",
    "parameters": "String, Int",
    "example": "${\"abcabc\"?index_of(\"bc\")}",
    "output": "1",
    "template": "index_of(p1, p2)"
  },
  {
    "name": "JSON String",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Escapes the String with the escaping rules of JSON language String literals, so it's safe to insert the value into a String literal. Note that it will not add quotation marks around the inserted value; you meant to use this inside the String literal.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?json_String"
  },
  {
    "name": "Keep after",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Removes the part of the String that is not after the first occurrence of the given subString.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"abcdefgh\"?keep_after(\"de\")}",
    "output": "fgh",
    "template": "?keep_after(p1)"
  },
  {
    "name": "Keep after last",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Same as keep_after, but keeps the part after the last occurrence of the parameter, rather than after the first.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"foo.bar.txt\"?keep_after_last(\".\")}",
    "output": "txt",
    "template": "?keep_after_last(p1)"
  },
  {
    "name": "Keep before",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Removes the part of the String that starts with the given subString. If the parameter String is not found, it will return the original String unchanged. If the parameter String is a 0-length String, it will return an empty String.",
    "insertRule": "append",
    "parameters": "String, String",
    "example": "${\"foo : bar\"?keep_before(r\"\\s*:\\s*\", \"r\")}",
    "output": "foo",
    "template": "?keep_before(p1, p2)"
  },
  {
    "name": "Keep before last",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Same as keep_before, but keeps the part before the last occurrence of the parameter, rather than after the first.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"foo.bar.txt\"?keep_before_last(\".\")}",
    "output": "foo.bar",
    "template": "?keep_before_last(p1)"
  },
  {
    "name": "Last index of",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Returns the index within this String of the last (rightmost) occurrence of the specified subString. It returns the index of the first (leftmost) character of the subString. For example: \"abcabc\"?last_index_of(\"ab\") will return 3. Also, you can specify the index to start the search from. For example, \"abcabc\"?last_index_of(\"ab\", 2) will return 0. Note that the second parameter indicates the maximum index of the start of the subString. There is no restriction on the numerical value of the second parameter: if it is negative, it has the same effect as if it were zero, and if it is greater than the length of this String, it has the same effect as if it were equal to the length of this String. Decimal values will be truncated to inegers.",
    "insertRule": "append",
    "parameters": "String, Int",
    "example": "${\"abcabc\"?last_index_of(\"ab\")}",
    "output": "3",
    "template": "?last_index_of(String)"
  },
  {
    "name": "Length",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Return the number of characters in the String.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"abcabc\"?length}",
    "output": "6",
    "template": "?length"
  },
  {
    "name": "Lower case",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The lower case version of the String.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"GrEeN MoUsE\"?lower_case}",
    "output": "green mouse",
    "template": "?lower_case"
  },
  {
    "name": "Number",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String converted to numerical value. The number must be in \"computer language\" format. That is, it must be in the locale independent form, where the decimal separator is dot, and there's no grouping.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"13\"?number}",
    "output": "13",
    "template": "?number"
  },
  {
    "name": "Replace",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String converted to numerical value. The number must be in \"computer language\" format. That is, it must be in the locale independent form, where the decimal separator is dot, and there's no grouping.",
    "insertRule": "append",
    "parameters": "String, String",
    "example": "${\"doom\"?replace(\"doo\", \"roo\")}",
    "output": "room",
    "template": "?replace(p1, p2)"
  },
  {
    "name": "Split",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "It is used to split a String into a sequence of Strings along the occurrences of another String.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"some,,test,text,\"?split(\",\")}",
    "output": "",
    "template": "?split(p1)"
  },
  {
    "name": "Starts_with",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Returns if this String starts with the specified subString.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${\"redirect\"?starts_with(\"red\")}",
    "output": "true",
    "template": "?starts_with(p1)"
  },
  {
    "name": "Trim",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String without leading and trailing white-space.",
    "insertRule": "append",
    "parameters": "",
    "example": "(${\"  green mouse  \"?trim})",
    "output": "(green mouse)",
    "template": "?trim"
  },
  {
    "name": "Truncate",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "Cuts off the end of a String if that's necessary to keep it under a the length given as parameter, and appends a terminator String ([...] by default) to indicate that the String was truncated.",
    "insertRule": "append",
    "parameters": "Int",
    "example": "${\"This is a too long name\"?truncate(16)}",
    "output": "This is a [...]",
    "template": "?truncate(p1)"
  },
  {
    "name": "Un-capitalize first",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The String with the very first word of the String un-capitalized.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"GReen mouse\"?uncap_first}",
    "output": "gReen mouse",
    "template": "?uncap_first"
  },
  {
    "name": "Upper case",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "The upper case version of the String.",
    "insertRule": "append",
    "parameters": "",
    "example": "${\"GReen mouse\"?upper_case}",
    "output": "GREEN MOUSE",
    "template": "?upper_case"
  },
  {
    "name": "Word list",
    "type": "Filters",
    "subcategory": "String",
    "documentation": "A sequence that contains all words of the String in the order as they appear in the String. Words are continual character sequences that contain any character but white-space.",
    "insertRule": "append",
    "parameters": "",
    "example": "\"<#assign words = \"\"   a bcd, .   1-2-3\"\"?word_list>\n<#list words as word>[${word}]</#list>\"",
    "output": "[a][bcd,][.][1-2-3]",
    "template": "?word_list"
  },
  {
    "name": "Abs",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Gives the absolute value of a number. For example x?abs , if x is -5, will evaluate to 5.",
    "insertRule": "append",
    "parameters": "",
    "example": "${-100100?abs}",
    "output": "100100",
    "template": "?abs"
  },
  {
    "name": "C",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "This built-in converts a number to string for a \"computer language\" as opposed to for human audience. That is, it formats with the rules that programming languages used to use, which is independent of all the locale and number format settings of FreeMarker. It always uses dot as decimal separator, and it never uses grouping separators (like 3,000,000), nor exponential form (like 5E20), nor superfluous leading or trailing 0-s (like 03 or 1.0), nor + sign (like +1). It will print at most 16 digits after the decimal dot, and thus numbers whose absolute value is less than 1E-16 will be shown as 0",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?c"
  },
  {
    "name": "Is infinite",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Tells if a number is floating point infinite (according to IEEE 754). For example, someNumber?is_infinite evaluates to true or false depending on if the value of someNumber is infinite or not. Of course, if the underlying number is not of floating point type, this will always return false.",
    "insertRule": "append",
    "parameters": "",
    "example": "${someNumber?is_infinite}",
    "output": "",
    "template": "?is_infinite"
  },
  {
    "name": "Is NaN",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Tells if a number is floating point NaN (according to IEEE 754). For example, someNumber?is_nan evaluates to true or false depending on if the value of someNumber is NaN or not. Of course, if the underlying number is not of floating point type, this will always return false.",
    "insertRule": "append",
    "parameters": "",
    "example": "${someNumber?is_nan}",
    "output": "",
    "template": "?is_nan"
  },
  {
    "name": "Lower abc",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Converts 1, 2, 3, etc., to the string \"a\", \"b\", \"c\", etc. When reaching \"z\", it continues like \"aa\", \"ab\", etc. This is the same logic that you can see in column labels in spreadsheet applications (like Excel or Calc). The lowest allowed number is 1. There's no upper limit. If the number is 0 or less or it isn't an integer number then the template processing will be aborted with error.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list 1..5 as n>${n?lower_abc} </#list>",
    "output": "a b c d e",
    "template": "?lower_abc"
  },
  {
    "name": "Round",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Rounds to the nearest whole number. If the number ends with .5, then it rounds upwards (i.e., towards positive infinity)",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?round"
  },
  {
    "name": "Floor",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Rounds the number downwards (i.e., towards neagative infinity)",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?floor"
  },
  {
    "name": "Ceiling",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Rounds the number upwards (i.e., towards positive infinity)",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?ceiling"
  },
  {
    "name": "String",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Converts a number to a string. In its simplest form (expression?string) it uses the default format that the programmer has specified via the number_format and the locale configuration settings. You can also specify a number format explicitly with this built-in, as it will be shown later.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?string"
  },
  {
    "name": "Upper abc",
    "type": "Filters",
    "subcategory": "Numbers",
    "documentation": "Converts 1, 2, 3, etc., to the string \"A\", \"B\", \"C\", etc. When reaching \"Z\", it continues like \"AA\", \"AB\", etc. This is the same logic that you can see in column labels in spreadsheet applications (like Excel or Calc). The lowest allowed number is 1. There's no upper limit. If the number is 0 or less or it isn't an integer number then the template processing will be aborted with error.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?upper_abc"
  },
  {
    "name": "Date",
    "type": "Filters",
    "subcategory": "Date and Time",
    "documentation": "These built-in can be used to specify which parts of the date-like variable are in.",
    "insertRule": "append",
    "parameters": "",
    "example": "${.now?date}",
    "output": "",
    "template": "?date"
  },
  {
    "name": "Time",
    "type": "Filters",
    "subcategory": "Date and Time",
    "documentation": "These built-ins can be used to specify which parts of the date-like variable are in use.Only the time of the day, no date part.",
    "insertRule": "append",
    "parameters": "",
    "example": "${.now?time}",
    "output": "",
    "template": ""
  },
  {
    "name": "Date and time",
    "type": "Filters",
    "subcategory": "Date and Time",
    "documentation": "These built-ins can be used to specify which parts of the date-like variable are in use. Both date and time.",
    "insertRule": "append",
    "parameters": "",
    "example": "${.now?datetime}",
    "output": "",
    "template": "?datetime"
  },
  {
    "name": "Date to string",
    "type": "Filters",
    "subcategory": "Date and Time",
    "documentation": "This built-in converts a date to a string, with the specified formatting. The desired format can be specified like <span>?string.<em>format</em></span>.",
    "insertRule": "append",
    "parameters": "<ul><li><span>format</span>: short, medium, long, full, xs, iso</li></ul>",
    "example": "${.now?time?string.short}",
    "output": "",
    "template": "?string.format"
  },
  {
    "name": "Boolean to string",
    "type": "Filters",
    "subcategory": "Boolean",
    "documentation": "Converts a boolean to a string.",
    "insertRule": "append",
    "parameters": "String, String",
    "example": "${foo?string(\"yes\", \"no\")}",
    "output": "",
    "template": "?string(p1, p2)"
  },
  {
    "name": "Then",
    "type": "Filters",
    "subcategory": "Boolean",
    "documentation": "Used like booleanExp?then(whenTrue, whenFalse), fills the same role as the ternary operator in C-like languages (i.e., booleanExp ? whenTrue : whenFalse). If booleanExp evaluates to boolean true then it evaluates and returns its first argument, or else if booleanExp evaluates to boolean false then it evaluates and return its second argument. Off course, all three expression can be arbitrary complex. The argument expressions can have any type, even different types.",
    "insertRule": "append",
    "parameters": "String, String",
    "example": "<#assign x = 10>\n<#assign y = 20>\n<#-- Prints 100 plus the maximum of x and y: -->\n${100 + (x < y)?then(x, y)}",
    "output": "120",
    "template": "?then(p1, p2)"
  },
  {
    "name": "Chunk",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "This built-in splits a sequence into multiple sequences of the size given with the 1st parameter to the built-in (like mySeq?chunk(3)). The result is the sequence of these sequences. The last sequence is possibly shorter than the given size, unless the 2nd parameter is given (like mySeq?chunk(3, '-')), that is the item used to make up the size of the last sequence to the given size.",
    "insertRule": "append",
    "parameters": "Int, String",
    "example": "<#assign seq = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']>\n\n<#list seq?chunk(4) as row>\n  <#list row as cell>${cell} </#list>\n</#list>",
    "output": "a b c d\ne f g h\ni j",
    "template": "?chunk(p1)"
  },
  {
    "name": "Drop while",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns a new sequence that contains the elements from the input sequence starting with from the first element that does not match the parameter predicate (condition). After that, all elements are included, regardless if they match the predicate or not. See the filter built-in for more details about parameters, and other details, but note that the condition in filter has opposite meaning (what to keep, instead of what to drop).",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign xs = [1, 2, -3, 4, -5, 6]>\n\nDrop while positive:\n<#list xs?drop_while(x -> x > 0) as x>${x} </#list>",
    "output": "Drop while positive:\n-3 4 -5 6",
    "template": "?drop_while(condition)"
  },
  {
    "name": "Filter",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns a new sequence that only contains the elements for which the parameter condition (the predicate) returns true.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign xs = [1, -2, 3, 4, -5]>\nPositives:\n<#list xs?filter(x -> x > 0) as x>${x} </#list>",
    "output": "Positives:\n1 3 4",
    "template": "?filter(el => condition)"
  },
  {
    "name": "First",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the first item of the sequence. Thus value?first is the same as value[0], except that, since FreeMarker 2.3.26, value?first also works if value doesn't support getting items with numerical index, but still supports to be listed. If the sequence or collection is empty, the result will be a missing value",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign colors = [\"red\", \"green\", \"blue\"]>\n${colors?first}",
    "output": "red",
    "template": "?first"
  },
  {
    "name": "Join",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Concatenates the items of a sequence to a single string, with the given separator.",
    "insertRule": "append",
    "parameters": "String",
    "example": "<#assign colors = [\"red\", \"green\", \"blue\"]>\n${colors?join(\", \")}",
    "output": "red, green, blue",
    "template": "?join(p1)"
  },
  {
    "name": "Last",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "The last subvariable of the sequence. Template processing will die with error if the sequence is empty.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign colors = [\"red\", \"green\", \"blue\"]>\n${colors?last)}",
    "output": "blue",
    "template": "?last"
  },
  {
    "name": "Map",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns an new sequence where all elements are replaced with the result of the parameter lambda, function, or method.",
    "insertRule": "append",
    "parameters": "Condition",
    "example": "<#assign userNames = users?map(user -> user.name)>",
    "output": "",
    "template": "?map(el => condition)"
  },
  {
    "name": "Min",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the smaller (min) item of the sequence (or collection). The items must be either all numbers, or all date/time values of the same kind (date-only, time-only, date-time), or else a comparison error will occur.",
    "insertRule": "append",
    "parameters": "",
    "example": "${[1, 2, 3]?min}",
    "output": "1",
    "template": "?min"
  },
  {
    "name": "Max",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the greatest (max) item of the sequence (or collection). The items must be either all numbers, or all date/time values of the same kind (date-only, time-only, date-time), or else a comparison error will occur.",
    "insertRule": "append",
    "parameters": "",
    "example": "${[1, 2, 3]?min}",
    "output": "3",
    "template": "?max"
  },
  {
    "name": "Reverse",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "The sequence with reversed order.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?reverse"
  },
  {
    "name": "Contains",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Tells if the sequence contains the specified value (according the == operator of the template language). It has 1 parameter, the value to find. ",
    "insertRule": "append",
    "parameters": "The value to find",
    "example": "<#assign x = [\"red\", 16, \"blue\", \"cyan\"]>\n\"blue\": ${x?seq_contains(\"blue\")?string(\"yes\", \"no\")}",
    "output": "\"blue\": yes",
    "template": "?seq_contains(p1)"
  },
  {
    "name": "Sequence index of",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the index of the first occurrence of a value in the sequence, or -1 if the sequence doesn't contain the specified value. The value to find is specified as the first parameter. ",
    "insertRule": "append",
    "parameters": "The value to find",
    "example": "<#assign x = [\"red\", 16, \"blue\", \"cyan\"]>\n\"index\": ${x?seq_index_of(16)}",
    "output": "\"index\": 1",
    "template": "?seq_index_of(p1)"
  },
  {
    "name": "Sequence last index of",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the index of the last occurrence of a value in the sequence, or -1 if the sequence doesn't contain the specified value. That is, it is the same as seq_index_of, just it searches backward starting from the last item of the sequence. It also supports the optional 2nd parameter that specifies the index where the searching is started.",
    "insertRule": "append",
    "parameters": "The value to find",
    "example": "<#assign x = [\"red\", 16, \"blue\", \"cyan\", 16]>\n\"last index\": ${x?seq_last_index_of(16)}",
    "output": "\"last index\": 4",
    "template": "?seq_last_index_of(p1)"
  },
  {
    "name": "Size",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "The number of sub variables in sequence (as a numerical value). The highest possible index in sequence s is s?size - 1 (since the index of the first subvariable is 0) assuming that the sequence has at least one subvariable.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign x = [\"red\", 16, \"blue\", \"cyan\", 16]>\n\"x size\": ${x?size}",
    "output": "5",
    "template": "?size"
  },
  {
    "name": "Sort",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "The number of sub variables in sequence (as a numerical value). The highest possible index in sequence s is s?size - 1 (since the index of the first subvariable is 0) assuming that the sequence has at least one subvariable.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#assign x = [\"y\", \"b\", \"z\", \"a\", \"m\"]?sort>\n<#list x as i>${i} </#list>",
    "output": "a b m y z ",
    "template": "?sort"
  },
  {
    "name": "Sort by",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns the sequence of hashes sorted by the given hash subvariable in ascending order. (For descending order use this and then the reverse built in.) The rules are the same as with the sort built-in, except that the sub variables of the sequence must be hashes, and you have to give the name of a hash subvariable that will decide the order. ",
    "insertRule": "append",
    "parameters": "String",
    "example": "<#assign ls = [\n  {\"name\":\"whale\", \"weight\":2000},\n  {\"name\":\"Barbara\", \"weight\":53},\n  {\"name\":\"zeppelin\", \"weight\":-200},\n  {\"name\":\"aardvark\", \"weight\":30},\n  {\"name\":\"beetroot\", \"weight\":0.3}\n]>\nOrder by name:\n<#list ls?sort_by(\"name\") as i>\n- ${i.name}: ${i.weight}\n</#list>",
    "output": "Order by name:\n- aardvark: 30\n- Barbara: 53\n- beetroot: 0.3\n- whale: 2000\n- zeppelin: -200",
    "template": "?sort_by(p1)"
  },
  {
    "name": "Take while",
    "type": "Filters",
    "subcategory": "Sequences",
    "documentation": "Returns a sequence that only contains the elements of the input sequence which are before the first element that doesn't match the parameter predicate (filter condition). ",
    "insertRule": "append",
    "parameters": "Condition",
    "example": "<#assign xs = [1, 2, -3, 4, -5, 6]>\n\nTake while positive:\n<#list xs?take_while(x -> x > 0) as x>${x} </#list>",
    "output": "Take while positive:\n1 2",
    "template": "?take_while(x -> condition)"
  },
  {
    "name": "Ancestors",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "A sequence that contains all the node's ancestors, starting with the immediate parent and ending with the root node. The result of this built-in is also a method, by which you can filter the result with the full-qualified name of the node.",
    "insertRule": "append",
    "parameters": "String",
    "example": "${node?ancestors(\"section\")}",
    "output": "",
    "template": "?ancestors(p1)"
  },
  {
    "name": "Children",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "A sequence that contains all of this node's child nodes (i.e. immediate descendant nodes).",
    "insertRule": "append",
    "parameters": "String",
    "example": "${node?children(\"section\")}",
    "output": "",
    "template": "?children(p1)"
  },
  {
    "name": "Next sibling",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "Returns the following sibling node of the node. (Two nodes in a tree are said to be siblings if they are on the same level and are directly next to each other.) If there's no such node, the expression node?next_sibling?? evaluates to false.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?next_sibling"
  },
  {
    "name": "Node namespace",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "Returns the namespace string of the node. FreeMarker does not define the exact meaning of node namespace; it depends on what your node variables are modeling. It's possible that a node doesn't have any node namespace defined. In this case, the built-in should evaluate to undefined variable (i.e. node?node_namespace?? is false), so you can't use the returned value.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?node_namespace"
  },
  {
    "name": "Node type",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "A string that describes the type of the node. FreeMarker does not define the exact meaning of node type; it depends on what your variables are modeling. It's possible that a node doesn't support node type at all. In this case, the built-in evaluates to an undefined value, so you can't use the returned value. (You can still check if a node supports the type property with node?node_type??.)",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?node_type"
  },
  {
    "name": "Parent",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "Returns the node that is this node's immediate parent in the node tree. The root node has no parent node, so for the root node, the expression node?parent?? evaluates to false.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?parent"
  },
  {
    "name": "Previous sibling",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "Returns the previous sibling node of the node.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?previous_sibling"
  },
  {
    "name": "Root",
    "type": "Filters",
    "subcategory": "Nodes",
    "documentation": "The node that is the root of the tree of nodes to which this node belongs.According to W3C, the root of an XML document is not the topmost element node, but the document itself, which is the parent of the topmost element. For example, if you want to get the topmost element of the XML (the so called \"document element\"; do not mix it with the \"document\"), which is called foo, then you have to write someNode?root.foo. If you write just someNode?root, then you get the document itself, and not the document element.",
    "insertRule": "append",
    "parameters": "",
    "example": "",
    "output": "",
    "template": "?previous_sibling"
  },
  {
    "name": "Counter",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Returns the 1-based index where the iteration (which is identified by the Loop variables name) currently stands.",
    "insertRule": "append",
    "parameters": "String",
    "example": "<#list ['a', 'b', 'c'] as i>\n  ${i?counter}: ${i}\n</#list>",
    "output": "1: a\n2: b\n3: c",
    "template": "?counter"
  },
  {
    "name": "Has next",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Tells if the item where the iteration (which is identified by the Loop variables name) currently stands is not the last item.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c'] as i>${i?has_next?c} </#list>",
    "output": "true true false ",
    "template": "?has_next"
  },
  {
    "name": "Index",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Returns the 0-based index where the iteration (which is identified by the Loop variables name) currently stands.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c'] as i>\n  ${i?index}: ${i}\n</#list>",
    "output": "0: a\n1: b\n2: c",
    "template": "?index"
  },
  {
    "name": "Is even item",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Tells if the item where the iteration (which is identified by the Loop variables name) currently stands has an even 1-based index.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c', 'd'] as i>${i?is_even_item?c} </#list>",
    "output": "false true false true",
    "template": "?is_even_item"
  },
  {
    "name": "Is first",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Tells if the item where the iteration (which is identified by the Loop variables name) currently stands is the first item.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c'] as i>${i?is_first?c} </#list>",
    "output": "true false false",
    "template": "?is_first"
  },
  {
    "name": "Is last",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Tells if the item where the iteration (which is identified by the Loop variables name) currently stands is the first item.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c'] as i>${i?is_first?c} </#list>",
    "output": "true false false",
    "template": "?is_first"
  },
  {
    "name": "Is odd item",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Tells if the item where the iteration (which is identified by the Loop variables name) currently stands has an odd 1-based index.",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c', 'd'] as i>${i?is_odd_item?c} </#list>",
    "output": "true false true false",
    "template": "?is_odd_item"
  },
  {
    "name": "Item cycle",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "This is a more generic version of the item_parity built-in, where you can specify what value to use instead of \"odd\" and \"even\". It also allows more than 2 values that it will cycle through.",
    "insertRule": "append",
    "parameters": "The type of the arguments can be anything, they doesn't have to be strings.",
    "example": "<#list ['a', 'b', 'c'] as i>\n  <tr class=\"${i?item_cycle('row1', 'row2')}\">${i}</tr>\n</#list>",
    "output": "<tr class=\"row1\">a</tr>\n<tr class=\"row2\">b</tr>\n<tr class=\"row1\">c</tr>",
    "template": "?item_cycle(p1)"
  },
  {
    "name": "Item parity",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Returns \"odd\" or \"even\" string value, depending on the parity of the 1-based index where the iteration (which is identified by the Loop variables name) currently stands. ",
    "insertRule": "append",
    "parameters": "The type of the arguments can be anything, they doesn't have to be strings.",
    "example": "<#list ['a', 'b', 'c', 'd'] as i>\n  <tr class=\"${i?item_parity}Row\">${i}</tr>\n</#list>",
    "output": "<tr class=\"oddRow\">a</tr>\n<tr class=\"evenRow\">b</tr>\n<tr class=\"oddRow\">c</tr>\n<tr class=\"evenRow\">d</tr>",
    "template": "?item_parity"
  },
  {
    "name": "Item parity cap",
    "type": "Filters",
    "subcategory": "Loop variables",
    "documentation": "Returns \"odd\" or \"even\" string value, depending on the parity of the 1-based index where the iteration (which is identified by the Loop variables name) currently stands. ",
    "insertRule": "append",
    "parameters": "",
    "example": "<#list ['a', 'b', 'c', 'd'] as i>\n  <tr class=\"row${i?item_parity_cap}\">${i}</tr>\n</#list>",
    "output": "<tr class=\"rowOdd\">a</tr>\n<tr class=\"rowEven\">b</tr>\n<tr class=\"rowOdd\">c</tr>\n<tr class=\"rowEven\">d</tr>",
    "template": "?item_parity_cap"
  }
]